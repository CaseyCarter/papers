\begingroup
\def\hd{\begin{tabular}{lll}
          \textbf{Document Number:} & {\larger\docno}                            \\
          \textbf{Date:}            & \reldate                                   \\
          \textbf{Audience:}        & Library Evolution Working Group            \\
          \textbf{Author:}          & Casey Carter \tcode{<Casey@Carter.net>}    \\
          \textbf{Author:}          & Gor Nishanov \tcode{<gorn@microsoft.com>}  \\
        % \textbf{Author:}          & Lewis Baker \tcode{<lewisbaker@gmail.com>} \\
          \end{tabular}
}
\newlength{\hdwidth}
\settowidth{\hdwidth}{\hd}
\hfill\begin{minipage}{\hdwidth}\hd\end{minipage}
\endgroup

\vspace{0.5cm}
\begin{center}
\textbf{\Huge \doctitle}
\end{center}

\vspace{0.5cm}

\chapter{Overview}

The coroutines TS has introduced a language capability that allows functions to be suspended and later resumed. One of the key applications for this new feature is to make it easier to write asynchronous code. However, the coroutines TS itself does not include any concrete coroutine types that directly support writing asynchronous code.

This paper proposes adding a new type, \tcode{std::lazy<T>}, to the standard library to enable creation and composition of coroutines representing asynchronous computation.

\begin{note}
SG1 wants to reserve the name \tcode{std::task} for something else. SG1 requested to pick a different name. LEWG chose \tcode{lazy}.
\end{note}

\begin{codeblock}
#include <lazy>
#include <string>

struct record {
  int id;
  std::string name;
  std::string description;
};

std::lazy<record> load_record(int id);
std::lazy<> save_record(record r);

std::lazy<void> modify_record() {
  record r = co_await load_record(123);
  r.description = "Look, ma, no blocking!";
  co_await save_record(std::move(r));
}
\end{codeblock}

The interface of lazy is intentionally minimal and designed for efficiency. In fact, the only operation you can do with the lazy is to await on it.

\begin{codeblock}
template<class T>
class [[nodiscard]] lazy {
public:
  lazy(lazy&& that) noexcept;
  ~lazy();
  unspecified operator co_await(); // \expos
};
\end{codeblock}

While such small interface may seem unusual at first, subsequent sections will clarify the rationale for this design.

\section{Why not use futures with \tcode{future.then}?}

The \tcode{std::future} type is inherently inefficient and cannot be used for efficient composition of asynchronous operations.
The unavoidable overhead of futures is due to:
\begin{itemize}
\item allocation/deallocation of the shared state object,
\item atomic increment/decrement for managing the lifetime of the shared state object,
\item synchronization between setting of the result and getting the result, and
\item (with \tcode{.then}) scheduling overhead of starting execution of subscribers to \tcode{.then}.
\end{itemize}

Consider the following example:
\begin{codeblock}
lazy<int> coro() {
  int result = 0;
  while (int v = co_await async_read())
    result += v;
  co_return result;
}
\end{codeblock}
where \tcode{async_read()} is some asynchronous operation that takes, say, 4ns to perform.
We would like to factor out the logic into two coroutines:
\begin{codeblock}
lazy<int> subtask() {
  co_return co_await async_read();
}

lazy<int> coro_refactored() {
  int result = 0;
  while (int v = co_await subtask())
    result += v;
  co_return result;
}
\end{codeblock}

Breaking a single \tcode{co_await} into its own function may seem silly, but it allows us to measure the overhead of composition of tasks. With the proposed \tcode{lazy}, our per-operation cost grew from 4ns to 6ns and did not incur any heap allocations. Moreover, this overhead of 2ns is not inherent to \tcode{lazy} and we anticipate that with improved coroutine optimization technology we will be able to drive the overhead close to zero.
To estimate the cost of composition with \tcode{std::future}, we used the following code:
\begin{codeblock}
int fut_test() {
  int count = 1'000'000;
  int result = 0;

  while (count > 0) {
    promise p;
    auto fut = p.get_future();
    p.set_value(count--);
    result += fut.get();
  }
  return result;
}
\end{codeblock}
As measured on the same system (Linux, clang 6.0, libc++), we get \emph{133ns} per operation! Here is the visual illustration.

\begin{tabular}{rl}
        op cost: & ** \\
  lazy overhead: & * \\
future overhead: & ***************************************************************** \\
\end{tabular}

Being able to break apart bigger functions into a set of smaller ones and being able to compose software by putting together small pieces is fundamental requirement for a good software engineering since the 60s. The overhead of \tcode{std::future} and types similar in behavior makes them unsuitable as coroutine types.

\subsubsection{Removing \tcode{future} overhead: Memory Allocation}

Consider the only operation that is available on a \tcode{lazy}, namely, awaiting on it.
\begin{codeblock}
lazy<X> g();
lazy<Y> f() {
  // ...
  X x = co_await g();
  // ...
}
\end{codeblock}
The caller coroutine \tcode{f} owns the lazy object for \tcode{g} that is created and destroyed at the end of the full expression containing \tcode{co_await}. This allows the compiler to determine the lifetime of the coroutine and apply Heap Allocation eLision Optimization~\cite{P0981R0}, which allocates a coroutine's state as if it were a local variable in its caller.

\subsubsection{Removing \tcode{future} overhead: Reference counting}

The coroutine state is not shared. The \tcode{lazy} type only allows moving pointer to a coroutine from one \tcode{lazy} object to another. Lifetime of a coroutine is linked to its \tcode{lazy} object, and the \tcode{lazy} object's destructor destroys the coroutine, thus, no reference counting is required.

In a later section about cancellation we will cover the implications of this design decision.

\subsubsection{Removing \tcode{future} overhead: Set/Get synchronization}

The \tcode{lazy} coroutine always starts suspended. This allows not only to avoid synchronization when attaching a continuation, but also enables solving via composition how and where coroutine needs to get executed and allows to implement advanced execution strategies like continuation stealing.

\subsubsection{Removing \tcode{future} overhead: Scheduling overhead}
Consider the following code fragment:
\begin{codeblock}
int result = 0;
while (int v = co_await async_read())
  result += v;
\end{codeblock}
Let's say that \tcode{async_read} returns a \tcode{future}. That \tcode{future} cannot resume directly the coroutine that is awaiting on it as it will, in effect, transform the loop into unbounded recursion.

On the other hand, coroutines have built-in support for symmetric coroutine transfer~\cite{P0913R1}. Since \tcode{lazy} object can only be created by a coroutine and the only way to get the result from a coroutine is by awaiting on it from another coroutine, the transfer of control from completing coroutine to awaiting coroutine is done in symmetric fashion, thus eliminating the need for extra scheduling interactions.

\subsection{Destruction and cancellation}
Note that the \tcode{lazy} type unconditionally destroys the coroutine in its destructor. It is safe to do, only if the coroutine has finished execution (at the final suspend point) or it is in a suspended state (waiting for some operation to complete), but, somehow, we know that the coroutine will never be resumed by the entity which was supposed to resume the coroutine on behalf of the operation that coroutine is awaiting upon. That is only possible if the underlying asynchronous facility support cancellation.

We strongly believe that support for cancellation is a required facility for writing asynchronous code and we struggled for awhile trying to decide what is the source of the cancellation, whether it is the \tcode{lazy} that must initiate cancellation - and therefore every await in every coroutine needs to understand how to cancel a particular operation it is being awaited upon - or every async operation is tied to a particular lifetime and cancellation domain and operations are cancelled in bulk by cancellation of the entire cancellation domain~\cite{P0399R0}.

We experimented with both approaches and reached the conclusion that not performing cancellation from the \tcode{lazy}, but, pushing it to the cancellation domain leads to more efficient implementation and is a simpler model for users.

\subsection{Why no move assignment?}

This is rather unorthodox decision and even authors of the paper did not completely agree on this topic. However, going with more restrictive model initially allows us to discover if the insight that lead to this decision was wrong. Initial design of the lazy, included move assignment, default constructor and swap. We removed them for two reasons.

First, when observing how lazy was used, we noticed that whenever, a variable-size container of tasks was created, we later realized that it was a suboptimal choice and a better solution did not require a container of tasks.

Second: move-assignment of a lazy is a ticking bomb. To make it safe, we would need to introduce per lazy cancellation of associated coroutines and it is a very heavy-weight solution.

At the moment we do not offer a move assignment, default constructor and swap. If good use cases, for which there are no better ways to solve the same problem are discovered, we can add them.

\subsection{Interaction with allocators}

The implementation of coroutine bindings for lazy is required to treat the case where first parameter to a coroutine is of type \tcode{allocator_arg_t}. If that is the case, the coroutine needs to have at least two arguments and the second one shall satisfy the \oldconcept{Allocator} requirements and if dynamic allocation required to store the coroutine state, implementation should use provided allocator to allocate and deallocate the coroutine state. Examples:
\begin{codeblock}
lazy<int> f(int, float); // uses default allocator if needed

lazy<int> f(allocator_arg_t, pmr::polymorphic_allocator<> a); // uses a to allocate, if needed

template<class Alloc>
lazy<int> f(allocator_arg_t, Alloc a); // uses allocator a to allocate. if needed
\end{codeblock}

\subsection{Interaction with executors}
Since coroutine starts suspended, it is up to the user to decide how it needs to get executed and where continuation needs to be scheduled.

Case 1: Starts in the current thread, resumes in the thread that triggered the completion of \tcode{f()}.
\begin{codeblock}
co_await f();
\end{codeblock}

Case 2: Starts in the current thread, resumes on executor \tcode{ex}.
\begin{codeblock}
co_await f().via(ex);
\end{codeblock}
\begin{note}
Member function via is not part of the lazy at the moment. We envision this as one possible way of how to express the desire to execute continuation in a different executor. For more details see P0975R0 that explores impact of coroutines on various existing proposals in flight~\cite{P0975R0}.
\end{note}

Case 3: Starts by an executor \tcode{ex}, resumes in the thread that triggered the completion of \tcode{f()}.
\begin{codeblock}
co_await spawn(ex, f());
\end{codeblock}

Case 4: Starts by an executor \tcode{ex1}, resumes on executor \tcode{ex2}.
\begin{codeblock}
co_await spawn(ex1, f()).via(ex2);
\end{codeblock}

The last case is only needed if \tcode{f()} cannot start executing in the current thread for some reason. We expect that this will not be a common case. Usually, when a coroutine has unusual requirements on where it needs to be executed it can be encoded directly in \tcode{f} without forcing the callers of \tcode{f} to do extra work. Typically, in this manner:
\begin{codeblock}
lazy<T> f() {
  co_await make_sure_I_am_on_the_right_thread();
  // ...
}
\end{codeblock}

\subsection{But what about \tcode{main}?}
As we mentioned in the beginning, the only operation that one can do on a lazy is to await on it (as if by \tcode{co_await} operator). Using an \grammarterm{await-expression} in a function turns it into a coroutine. But, this cannot go on forever, at some point, we have to interact with coroutine from a function that is not a coroutine itself, \tcode{main}, for example. What to do?

There could be several functions that can bridge the gap between synchronous and asynchronous world. For example:
\begin{codeblock}
template<class T> T sync_await(lazy<T>);
\end{codeblock}
This function starts the lazy execution in the current thread, and, if it gets suspended, it blocks until the result is available. To simplify the signature, we show \tcode{sync_await} only taking objects of lazy type. This function can be written generically to handle arbitrary awaitables.

Another function could be a variant of \tcode{std::async} that launches execution of a lazy on a thread pool and returns a future representing the result of the computation.
\begin{codeblock}
template<class T> T async(lazy<T>);
\end{codeblock}
One would use this version of \tcode{std::async} if blocking behavior of \tcode{sync_await} is undesirable.

\subsection{Implementation experience}

A version of proposed type has been used in shipping software that runs on hundreds of million devices in consumer hands. Also, a similar type has been implemented in most extensive coroutine abstraction library CppCoro~\cite{CppCoro}. This proposed type is minimal and efficient and can be used to build higher level abstraction by composition.

\chapter{Wording}

The technical specifications that follow take the form of excerpts
from the working draft N4901~\cite{N4901} with change markings:
\begin{itemize}
\item \removed{Text to be struck is in red with strikethough}, and
\item \added{text to be added is ``green'' with underline}.
\end{itemize}

\ednote{Add definitions to the \tcode{<coroutine>} synopsis:}

\setcounter{chapter}{17}
\setcounter{section}{12}
\setcounter{subsection}{1}
\rSec2[coroutine.syn]{Header \tcode{<coroutine>} synopsis}

\indexheader{coroutine}%
\indexlibraryglobal{noop_coroutine_handle}%
\begin{codeblock}
#include <compare>              // see \cxxref{compare.syn}

namespace std {
  [...]

  // \cxxref{coroutine.trivial.awaitables}, trivial awaitables
  struct suspend_never;
  struct suspend_always;

  @\added{// \ref{coroutine.awaitable}, awaitable concepts}@
  @\added{template<class T, class Promise = void>}@
  @\added{concept simple_awaitable = \seebelownc;}@

  @\added{template<class T, class Promise = void>}@
  @\added{concept awaitable = \seebelownc;}@
}
\end{codeblock}

\ednote{Insert new subclauses at the end of \cxxref{support.coroutine}:}

{\color{addclr}
\setcounter{subsection}{6}
\rSec2[coroutine.awaitable]{Awaitable concepts}

\pnum
The \libconcept{awaitable} and \libconcept{simple_awaitable} concepts
specify the requirements on a type
that is usable in an \grammarterm{await-expression}\cxxiref{expr.await}.

\begin{itemdecl}
template<class T>
concept @\exposid{suspend-result}@ = @\seebelownc@; // \expos

template<class T, class Promise = void>
concept simple_awaitable = requires(T& t, const coroutine_handle<Promise>& h) {
  { t.await_ready() } -> convertible_to<bool>; // not required to be equality-preserving
  { t.await_suspend(h) } -> @\exposidnc{suspend-result}@; // not required to be equality-preserving
  t.await_resume(); // not required to be equality-preserving
};

template<class T, class Promise = void>
concept @\exposidnc{has-member-co_await}@ = // \expos
  requires(T&& t) {
    { std::forward<T>(t).operator co_await() }
      -> simple_awaitable<Promise>; // not required to be equality-preserving
  };

template<class T, class Promise = void>
concept @\exposidnc{has-ADL-co_await}@ = // \expos
  requires(T&& t) {
    { operator co_await(std::forward<T>(t)) }
      -> simple_awaitable<Promise>; // not required to be equality-preserving
  };

template<class T, class Promise = void>
concept awaitable = @\exposid{has-member-co_await}@<T, Promise> ||
  @\exposid{has-ADL-co_await}@<T, Promise> || simple_awaitable<T, Promise>;
\end{itemdecl}

\begin{itemdescr}
\pnum
For a type \tcode{T},
\tcode{\exposid{suspend-result}<T>} is satisfied
if \tcode{T} denotes \tcode{void} or \tcode{bool}, or
if \tcode{T} is a specialization of \tcode{coroutine_handle}.

\pnum
For an expression $E$,
if \tcode{decltype(($E$))} satisfies
the \tcode{\libconcept{awaitable}<P>} concept
for some promise type \tcode{P},
then a \term{simple awaitable of $E$} is
an object satisfying the \tcode{\libconcept{simple_awaitable}<P>} concept
that is either the result of evaluation of $E$ itself
or the result of an application (if available)
of \tcode{operator co_await} to $E$.
\end{itemdescr}

\rSec2[coroutine.lazy]{Coroutine tasks}
\rSec3[coroutine.lazy.overview]{Overview}
\pnum
This subclause describes components that a program can use
to create coroutines representing asynchronous computations.

\rSec3[lazy.syn]{Header \tcode{<lazy>} synopsis}
\begin{codeblock}
namespace std {
  template<class T = void> class lazy;
  template<class T> class lazy<T&>;
  template<> class lazy<void>;
}
\end{codeblock}

\rSec3[coroutine.lazy.type]{Class template \tcode{lazy}}
\pnum
The class template \tcode{lazy} defines
a type for a coroutine lazy object
that can be associated with
a coroutine whose return type is
\tcode{lazy<T>} for some type \tcode{T}.
This subclause refers to such a coroutine as a lazy coroutine
and to type \tcode{T} as the eventual type of a lazy coroutine.

\begin{codeblock}
template<class T>
  class [[nodiscard]] lazy {
  public:
    lazy(lazy&& that) noexcept;
    ~lazy();
    \unspec operator co_await() &;  // \expos
    \unspec operator co_await() &&; // \expos
  };
\end{codeblock}

\pnum
The library provides specializations of \tcode{coroutine_traits}
as required to implement the following behaviors.

\pnum
A call to a lazy coroutine \tcode{f} shall return a lazy object \tcode{t} associated with that coroutine. The called coroutine shall be suspended at the initial suspend point\cxxiref{dcl.fct.def.coroutine}. Such a lazy object is considered to be in the armed state.

\pnum
The type of a lazy object shall satisfy the \libconcept{awaitable} concept, and awaiting on a lazy object in the armed state as if by \tcode{co_await t}\cxxiref{expr.await} shall register the awaiting coroutine \tcode{a} with the lazy object \tcode{t} and resume the coroutine \tcode{f}. At this point \tcode{t} is considered to be in the launched state. Awaiting on a lazy object that is not in the armed state has undefined behavior.

\pnum
Let \tcode{sa} be a simple awaitable of \tcode{t}\iref{coroutine.awaitable}. If the compound-statement of the function-body of the coroutine \tcode{f} completes with an unhandled exception, the awaiting coroutine \tcode{a} is resumed and an expression \tcode{sa.await_resume()} shall rethrow that exception.

\pnum
If the eventual type of a coroutine \tcode{f} is \tcode{void} and the coroutine completes due to an execution of a coroutine return statement\cxxiref{stmt.return.coroutine}, or flowing off the end of a coroutine, the awaiting coroutine \tcode{a} is resumed and an expression \tcode{sa.await_resume()} shall evaluate to \tcode{void}.

\pnum
If the eventual type of a coroutine \tcode{f} is not \tcode{void} and the coroutine completes due to an execution of a coroutine return statement\cxxiref{stmt.return.coroutine}, the operand of the coroutine return statement shall be stored in the coroutine state and the awaiting coroutine \tcode{a} is resumed and an expression \tcode{sa.await_resume()} shall return the stored value if \tcode{t} is an rvalue or reference to a stored value, otherwise.

\pnum
If in the definition of the coroutine g, the first parameter has type \tcode{allocator_arg_t}, then the coroutine shall have at least two arguments and the type of the second parameter shall satisfy the \oldconcept{Allocator} requirements\cxxiref{allocator.requirements.general} and if dynamic allocation is required to store the coroutine state\cxxiref{dcl.fct.def.coroutine}, implementation shall use the provided allocator to allocate and deallocate the coroutine state.

\pnum
If a \grammarterm{yield-expression}\cxxiref{expr.yield} occurs
in the suspension context of the lazy coroutine,
the program is ill-formed.

\rSec3[coroutine.lazy.mem]{Members}
\begin{itemdecl}
lazy(lazy&& that) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{*this} refers to the coroutine
originally referred to be \tcode{that}, if any,
and \tcode{that} refers to no coroutine.
\end{itemdescr}

\begin{itemdecl}
~lazy();
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
The coroutine referred to by \tcode{*this}, if any, is suspended.

\pnum
\effects
Destroys the coroutine referred to by \tcode{*this}, if any.
\end{itemdescr}
} % \color{addclr}
